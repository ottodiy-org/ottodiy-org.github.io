<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tinkercad models</title>
    <style>
        /* This is the container that captures mouse movements.
           It's set to the exact size of one frame.
        */
        #animation-container {
            width: 300px;  /* Frame Width */
            height: 202px; /* Frame Height */
            margin: 50px auto; /* Centered on page for demo */
            cursor: e-resize; /* Suggests horizontal dragging */
            border: 2px solid #ccc; /* Optional border */
            position: relative;
            overflow: hidden; /* Ensure nothing spills out */
        }

        /* This element actually holds the image.
           It will be shifted left and right behind the container window. 
        */
        #sprite-image {
            width: 100%;
            height: 100%;
            /* IMPORTANT: Replace 'robot-sprite.png' with your actual image path */
            background-image: url('quad-sprite.png'); 
            background-repeat: no-repeat;
            /* Start at the first frame (position 0 0) */
            background-position: 0px 0px; 
        }
    </style>
</head>
<body>


    <div id="animation-container">
        <div id="sprite-image"></div>
    </div>


    <script>
        // --- Configuration ---
        const FRAME_WIDTH = 300;   // The width of a single frame in pixels
        const FRAME_COUNT = 15;    // Total number of frames in the image strip

        // --- DOM Elements ---
        const container = document.getElementById('animation-container');
        const sprite = document.getElementById('sprite-image');

        // --- Variables for animation smoothness ---
        let isAnimating = false;
        let currentMouseX = 0;

        // --- Event Listener ---
        // Listen for mouse movement specifically over the container
        container.addEventListener('mousemove', function(e) {
            // Store the mouse X position relative to the container element
            // e.offsetX gives the mouse coordinate within the target element
            currentMouseX = e.offsetX;

            // Use requestAnimationFrame for smooth performance.
            // It prevents the browser from trying to update too many times per second.
            if (!isAnimating) {
                requestAnimationFrame(updateFrame);
                isAnimating = true;
            }
        });


        // --- The Core Logic ---
        function updateFrame() {
            // 1. Calculate the container's current width (in case it changes responsively, though fixed here)
            const containerWidth = container.offsetWidth;

            // 2. Determine how far across the container the mouse is as a percentage (0.0 to 1.0)
            // We ensure it doesn't go below 0 or above 1 using Math.max and Math.min
            let percentage = Math.max(0, Math.min(1, currentMouseX / containerWidth));

            // 3. Map that percentage to a specific frame index (0 to 14)
            // We floor the result to get an integer.
            // We use Math.min to ensure we never try to access frame #15 (which doesn't exist, as it's 0-indexed)
            let frameIndex = Math.min(FRAME_COUNT - 1, Math.floor(percentage * FRAME_COUNT));

            // 4. Calculate the negative X position for the background image.
            // e.g., Frame index 2 means shifting left by -600px (2 * 300)
            let backgroundPositionX = -(frameIndex * FRAME_WIDTH);

            // 5. Apply the new position to the style style
            sprite.style.backgroundPositionX = backgroundPositionX + 'px';

            // Reset animation lock
            isAnimating = false;
        }

    </script>
</body>
</html>
